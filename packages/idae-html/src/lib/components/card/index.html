<style>
    .card-root{padding:var(--gutter-md);font-size:var(--font-md);color:var(--color-foreground)}
    .card-container{display:flex;flex-wrap:wrap;gap:var(--gutter-md)}
    .card{box-shadow:0 4px 8px rgba(0,0,0,0.12);transition:box-shadow .2s;width:300px;border-radius:6px;overflow:hidden;background:var(--color-card);color:var(--color-card-foreground)}
    .card:hover{box-shadow:0 10px 24px rgba(0,0,0,0.14)}
    .card-header{padding:var(--gutter-sm);background:var(--color-secondary)}
    .card-body{padding:var(--gutter-md);background:var(--color-card)}
    .card-footer{padding:var(--gutter-sm);background:var(--color-accent);text-align:right}
</style>


<div data-component="card" class="card-container card-root">
    <div class="card">
        <div class="card-header"><h3>Card Title 1</h3></div>
        <div class="card-body"><slot name="body"><p>This is some content inside the card.</p></slot></div>
        <div class="card-footer"><button data-action>Action</button></div>
    </div>

    <div class="card">
        <div class="card-header"><h3>Card Title 2</h3></div>
        <div class="card-body"><slot name="body"><p>Another card with different content.</p></slot></div>
        <div class="card-footer"><button data-action>Action</button></div>
    </div>
</div>

<script type="module" lang="ts">
    import { be, core } from '$lib/core-engine.ts';

    core.registerComponent('card', {
        props: {},
        resources: [],
        script: (root, props) => {
            const rootEl = (root instanceof Element) ? root : (root as any).node || document;

            // If the page was server-rendered with slots, avoid client-side insertion.
            const serverRendered = core.serverSlotsEnabled && core.serverSlotsEnabled();
            if (!serverRendered) {
                // Client-side: fill any empty slots with fallback content or props
                const slotEls = Array.from(rootEl.querySelectorAll('slot')) as HTMLSlotElement[];
                slotEls.forEach((s) => {
                    if (!s.hasChildNodes()) {
                        const name = s.getAttribute('name') || 'default';
                        const txt = (props && props[name]) ? String((props as any)[name]) : 'Client-inserted content';
                        try { s.textContent = txt; } catch (e) {}
                    }
                });
            }
            const buttons = Array.from(rootEl.querySelectorAll('[data-action]')) as HTMLElement[];
            if (!buttons.length) return;

            const handlers: Function[] = [];

            function makeHandler(idx: number){
                return () => {
                    // Simple demo action: toggle a selected state
                    const btn = buttons[idx];
                    const card = btn.closest('.card') as HTMLElement | null;
                    if (!card) return;
                    const sel = card.getAttribute('data-selected') === 'true';
                    card.setAttribute('data-selected', String(!sel));
                    btn.textContent = sel ? 'Action' : 'Selected';
                };
            }

            buttons.forEach((b, i)=>{
                const h = makeHandler(i);
                handlers.push(h);
                be(b).on('click', h);
            });

            return () => { buttons.forEach((b, i)=>{ try{ be(b).off('click', handlers[i]); }catch(e){} }); };
        },
        on: {},
        meta: { author: 'idae-html', version: '1.0.0', description: 'Simple card examples with action handlers and cleanup.' }
    });
</script>